<!doctype html>
<html lang="sv">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Labyrintspel – prototyp</title>
    <style>
        html, body {
            margin: 0;
            height: 100%;
            background: #0b0d12;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .hud {
            position: fixed;
            inset: 0;
            pointer-events: none;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
            color: #cfd7ff;
            padding: 12px;
            text-shadow: 0 1px 2px rgba(0,0,0,.6);
        }

        .pill {
            display: inline-block;
            background: rgba(255,255,255,.06);
            border: 1px solid rgba(255,255,255,.08);
            padding: 6px 10px;
            border-radius: 999px;
            font-size: 13px;
        }

        .center {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .card {
            background: rgba(0,0,0,.55);
            border: 1px solid rgba(255,255,255,.12);
            border-radius: 14px;
            padding: 16px 18px;
            min-width: 260px;
            backdrop-filter: blur(6px);
            pointer-events: auto;
        }

            .card h2 {
                margin: 0 0 8px 0;
                font-size: 16px;
            }

            .card p {
                margin: 6px 0;
                font-size: 13px;
                opacity: .9;
            }

        .btn {
            margin-top: 10px;
            display: inline-block;
            cursor: pointer;
            background: #1d2bff;
            color: white;
            border: none;
            padding: 9px 12px;
            border-radius: 10px;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <canvas id="c"></canvas>

    <div class="hud">
        <span class="pill">Tryck: Space / Klick / Touch = sväng</span>
        <span class="pill" id="dist" style="margin-left:8px;">Distans: 0 m</span>
        <span class="pill" id="pb" style="margin-left:8px;">PB: 0 m</span>
    </div>

    <div class="center" id="overlay" style="display:none;">
        <div class="card">
            <h2>Krasch!</h2>
            <p id="resDist">Distans: 0 m</p>
            <p id="resPb">Personbästa: 0 m</p>
            <button class="btn" id="retryBtn">Försök igen</button>
        </div>
    </div>

    <div class="center" id="startOverlay">
        <div class="card">
            <h2>Redo?</h2>
            <p>Tryck för att starta.</p>
            <button class="btn" id="startBtn">Starta</button>
        </div>
    </div>


    <script>
        (() => {
            // ---------- Canvas setup ----------
            const canvas = document.getElementById("c");
            const ctx = canvas.getContext("2d");
            function resize() {
                const dpr = Math.max(1, window.devicePixelRatio || 1);
                canvas.width = Math.floor(innerWidth * dpr);
                canvas.height = Math.floor(innerHeight * dpr);
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }
            addEventListener("resize", resize);
            resize();

            // ---------- HUD / Overlays ----------
            const distEl = document.getElementById("dist");
            const pbEl = document.getElementById("pb");
            const overlay = document.getElementById("overlay");
            const resDist = document.getElementById("resDist");
            const resPb = document.getElementById("resPb");
            const retryBtn = document.getElementById("retryBtn");

            const startOverlay = document.getElementById("startOverlay");
            const startBtn = document.getElementById("startBtn");

            // ---------- World design ----------
            const corridorHalfWidth = 28;
            const speed = 220;
            const timingWindow = 0.22;
            const metersPerPixel = 0.03;

            function buildSpiralPoints() {
                const pts = [];
                let x = 0, y = 0;
                pts.push({ x, y });
                const step = 120;
                const turnsCount = 10;
                let len = step * 2;
                let dir = 0; // 0=right,1=up,2=left,3=down
                for (let i = 0; i < turnsCount; i++) {
                    const dx = (dir === 0) ? 1 : (dir === 2 ? -1 : 0);
                    const dy = (dir === 1) ? -1 : (dir === 3 ? 1 : 0);
                    x += dx * len;
                    y += dy * len;
                    pts.push({ x, y });
                    if (i % 2 === 1) len += step;
                    dir = (dir + 1) % 4;
                }
                return pts;
            }

            const pathPts = buildSpiralPoints();

            const segments = [];
            for (let i = 0; i < pathPts.length - 1; i++) {
                const a = pathPts[i], b = pathPts[i + 1];
                const horiz = (a.y === b.y);
                segments.push({
                    a, b,
                    horiz,
                    minX: Math.min(a.x, b.x), maxX: Math.max(a.x, b.x),
                    minY: Math.min(a.y, b.y), maxY: Math.max(a.y, b.y)
                });
            }

            const turns = [];
            for (let i = 1; i < pathPts.length - 1; i++) {
                turns.push({ x: pathPts[i].x, y: pathPts[i].y, index: i });
            }

            // ---------- Game state ----------
            let player, alive, distPx, pbMeters;
            let started; // startspärr

            function loadPB() {
                const v = localStorage.getItem("maze_pb_m") || "0";
                pbMeters = Math.max(0, parseFloat(v) || 0);
            }
            function savePB() {
                localStorage.setItem("maze_pb_m", pbMeters.toFixed(1));
            }

            function directionFromTo(a, b) {
                if (b.x > a.x) return { dx: 1, dy: 0 };
                if (b.x < a.x) return { dx: -1, dy: 0 };
                if (b.y > a.y) return { dx: 0, dy: 1 };
                return { dx: 0, dy: -1 };
            }

            function reset() {
                overlay.style.display = "none";
                alive = true;
                distPx = 0;

                started = false;
                startOverlay.style.display = "flex";

                const start = pathPts[0];
                const next = pathPts[1];
                const dir = directionFromTo(start, next);

                player = {
                    x: start.x,
                    y: start.y,
                    dir,
                    segIndex: 0,
                    nextTurn: 0,
                    desiredDir: null
                };

                updateHUD();
            }

            function crash() {
                if (!alive) return; // skyddar mot dubbelkrasch
                alive = false;

                const meters = distPx * metersPerPixel;
                if (meters > pbMeters) {
                    pbMeters = meters;
                    savePB();
                }

                resDist.textContent = `Distans: ${meters.toFixed(1)} m`;
                resPb.textContent = `Personbästa: ${pbMeters.toFixed(1)} m`;
                overlay.style.display = "flex";
                startOverlay.style.display = "none";
                updateHUD();
            }

            retryBtn.addEventListener("click", reset);

            function desiredDirectionAtTurn(currentSegIndex) {
                const nextSeg = segments[currentSegIndex + 1];
                if (!nextSeg) return player.dir;
                return directionFromTo(nextSeg.a, nextSeg.b);
            }

            function hasPassedTurn(turn) {
                if (player.dir.dx === 1) return player.x > turn.x;
                if (player.dir.dx === -1) return player.x < turn.x;
                if (player.dir.dy === 1) return player.y > turn.y;
                return player.y < turn.y;
            }

            function onPress() {
                if (!alive) return;

                // Startspärr: första trycket startar
                if (!started) {
                    started = true;
                    startOverlay.style.display = "none";
                    return;
                }

                const turn = turns[player.nextTurn];
                if (!turn) return;

                const distToTurn = Math.hypot(turn.x - player.x, turn.y - player.y);
                const distThreshold = speed * timingWindow;

                if (distToTurn > distThreshold) { crash(); return; }
                if (hasPassedTurn(turn)) { crash(); return; }

                if (!player.desiredDir) {
                    player.desiredDir = desiredDirectionAtTurn(player.segIndex);
                }
                player.dir = player.desiredDir;
                player.desiredDir = null;

                player.segIndex += 1;
                player.nextTurn += 1;
            }

            // Start-knappen startar också (utan att kräva “precision-klick” senare kan du lägga pointerdown också)
            startBtn.addEventListener("click", () => {
                if (!alive) return;
                if (!started) {
                    started = true;
                    startOverlay.style.display = "none";
                }
            });

            addEventListener("keydown", (e) => {
                if (e.code === "Space") { e.preventDefault(); onPress(); }
                if (!alive && (e.code === "Enter" || e.code === "Space")) { reset(); }
            }, { passive: false });

            canvas.addEventListener("pointerdown", (e) => {
                e.preventDefault();
                if (!alive) { reset(); return; }
                onPress();
            }, { passive: false });

            function insideCorridor(x, y) {
                const seg = segments[player.segIndex];
                if (!seg) return false;

                if (seg.horiz) {
                    const withinY = Math.abs(y - seg.a.y) <= corridorHalfWidth;
                    const withinX = (x >= seg.minX - corridorHalfWidth) && (x <= seg.maxX + corridorHalfWidth);
                    return withinX && withinY;
                } else {
                    const withinX = Math.abs(x - seg.a.x) <= corridorHalfWidth;
                    const withinY = (y >= seg.minY - corridorHalfWidth) && (y <= seg.maxY + corridorHalfWidth);
                    return withinX && withinY;
                }
            }

            // ---------- Camera ----------
            const cam = { x: 0, y: 0 };
            const zoom = 1.0;
            const lookAhead = 90;
            const camOffsetY = 60;

            function updateCamera() {
                cam.x = player.x + player.dir.dx * lookAhead;
                cam.y = player.y + player.dir.dy * lookAhead;
            }

            function draw() {
                ctx.clearRect(0, 0, innerWidth, innerHeight);

                updateCamera();

                const cx = innerWidth / 2;
                const cy = innerHeight / 2 + camOffsetY;

                function wx(x) { return (x - cam.x) * zoom + cx; }
                function wy(y) { return (y - cam.y) * zoom + cy; }

                // grid
                ctx.globalAlpha = 0.12;
                ctx.strokeStyle = "#9aa7ff";
                ctx.lineWidth = 1;
                const grid = 80;
                const leftW = cam.x - cx;
                const topW = cam.y - cy;
                const rightW = cam.x + cx;
                const bottomW = cam.y + cy;
                const gx0 = Math.floor(leftW / grid) * grid;
                const gy0 = Math.floor(topW / grid) * grid;
                for (let x = gx0; x < rightW + grid; x += grid) {
                    ctx.beginPath();
                    ctx.moveTo(wx(x), wy(topW));
                    ctx.lineTo(wx(x), wy(bottomW));
                    ctx.stroke();
                }
                for (let y = gy0; y < bottomW + grid; y += grid) {
                    ctx.beginPath();
                    ctx.moveTo(wx(leftW), wy(y));
                    ctx.lineTo(wx(rightW), wy(y));
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;

                // corridor
                ctx.fillStyle = "rgba(255,255,255,0.06)";
                for (const s of segments) {
                    if (s.horiz) {
                        const w = (s.maxX - s.minX);
                        ctx.fillRect(wx(s.minX), wy(s.a.y) - corridorHalfWidth, w, corridorHalfWidth * 2);
                    } else {
                        const h = (s.maxY - s.minY);
                        ctx.fillRect(wx(s.a.x) - corridorHalfWidth, wy(s.minY), corridorHalfWidth * 2, h);
                    }
                }

                // guideline
                ctx.strokeStyle = "rgba(80,140,255,0.9)";
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(wx(pathPts[0].x), wy(pathPts[0].y));
                for (let i = 1; i < pathPts.length; i++) {
                    ctx.lineTo(wx(pathPts[i].x), wy(pathPts[i].y));
                }
                ctx.stroke();

                // player
                ctx.fillStyle = alive ? "white" : "rgba(255,255,255,0.5)";
                ctx.beginPath();
                ctx.arc(wx(player.x), wy(player.y), 10, 0, Math.PI * 2);
                ctx.fill();

                // next turn marker
                const t = turns[player.nextTurn];
                if (t && alive) {
                    ctx.strokeStyle = "rgba(255,255,255,0.45)";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(wx(t.x), wy(t.y), 18, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            function updateHUD() {
                const meters = distPx * metersPerPixel;
                distEl.textContent = `Distans: ${meters.toFixed(1)} m`;
                pbEl.textContent = `PB: ${pbMeters.toFixed(1)} m`;
            }

            // ---------- Loop ----------
            let last = performance.now();
            function tick(now) {
                const dt = Math.min(0.033, (now - last) / 1000);
                last = now;

                if (alive && started) {
                    player.x += player.dir.dx * speed * dt;
                    player.y += player.dir.dy * speed * dt;
                    distPx += speed * dt;

                    if (!insideCorridor(player.x, player.y)) {
                        crash();
                    }
                }

                updateHUD();
                draw();
                requestAnimationFrame(tick);
            }

            // ---------- Init ----------
            loadPB();
            reset();
            requestAnimationFrame(tick);
        })();
    </script>

</body>
</html>
