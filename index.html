<!doctype html>
<html lang="sv">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Labyrintspel – prototyp</title>

    <style>
        html, body {
            margin: 0;
            height: 100%;
            background: #0b0d12;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: #fff;
        }

        .hud {
            position: fixed;
            inset: 0;
            pointer-events: none;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
            color: #cfd7ff;
            padding: 12px;
            text-shadow: 0 1px 2px rgba(0,0,0,.6);
        }

        .pill {
            display: inline-block;
            background: #111111;
            color: #ffffff;
            border: none;
            padding: 6px 10px;
            border-radius: 999px;
            font-size: 13px;
        }

        .center {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .card {
            background: #ffffff;
            color: #111111;
            border: 1px solid rgba(0,0,0,.12);
            border-radius: 14px;
            padding: 16px 18px;
            min-width: 260px;
            box-shadow: 0 12px 30px rgba(0,0,0,.25);
            pointer-events: auto;
        }

            .card h2 {
                margin: 0 0 8px 0;
                font-size: 16px;
                color: #000;
            }

            .card p {
                margin: 6px 0;
                font-size: 13px;
                color: #333;
                opacity: .95;
            }

        .btn {
            margin-top: 10px;
            display: inline-block;
            cursor: pointer;
            background: #1d2bff;
            color: white;
            border: none;
            padding: 9px 12px;
            border-radius: 10px;
            font-weight: 600;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>

    <div class="hud">
        <span class="pill">Tryck: Space / Klick / Touch = sväng</span>
        <span class="pill" id="dist" style="margin-left:8px;">Distans: 0 m</span>
        <span class="pill" id="pb" style="margin-left:8px;">PB: 0 m</span>
    </div>

    <div class="center" id="overlay" style="display:none;">
        <div class="card">
            <h2>Krasch!</h2>
            <p id="resDist">Distans: 0 m</p>
            <p id="resPb">Personbästa: 0 m</p>
            <button class="btn" id="retryBtn">Försök igen</button>
        </div>
    </div>

    <div class="center" id="startOverlay">
        <div class="card">
            <h2>Redo?</h2>
            <p>Tryck för att starta.</p>
            <button class="btn" id="startBtn">Starta</button>
        </div>
    </div>

    <script>
        (() => {
            // ---------- Canvas setup ----------
            const canvas = document.getElementById("c");
            const ctx = canvas.getContext("2d");

            function resize() {
                const dpr = Math.max(1, window.devicePixelRatio || 1);
                canvas.width = Math.floor(innerWidth * dpr);
                canvas.height = Math.floor(innerHeight * dpr);
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }
            addEventListener("resize", resize);
            resize();

            // ---------- HUD / Overlays ----------
            const distEl = document.getElementById("dist");
            const pbEl = document.getElementById("pb");
            const overlay = document.getElementById("overlay");
            const resDist = document.getElementById("resDist");
            const resPb = document.getElementById("resPb");
            const retryBtn = document.getElementById("retryBtn");

            const startOverlay = document.getElementById("startOverlay");
            const startBtn = document.getElementById("startBtn");

            // ---------- World / Tuning ----------
            const corridorHalfWidth = 28; // bredare = enklare
            const speed = 220;            // px/sec
            const timingWindow = 0.22;    // sekunder (± runt hörnet, approx)
            const metersPerPixel = 0.03;  // fake conversion för score

            // Maze-look
            const wallThickness = 18;     // väggtjocklek (12–24)
            const gridEnabled = true;     // true/false

            // ---------- Build spiral centerline ----------
            function buildSpiralPoints() {
                const pts = [];
                let x = 0, y = 0;
                pts.push({ x, y });

                const step = 120;
                const turnsCount = 10;
                let len = step * 2;
                let dir = 0; // 0=right,1=up,2=left,3=down

                for (let i = 0; i < turnsCount; i++) {
                    const dx = (dir === 0) ? 1 : (dir === 2 ? -1 : 0);
                    const dy = (dir === 1) ? -1 : (dir === 3 ? 1 : 0);

                    x += dx * len;
                    y += dy * len;

                    pts.push({ x, y });

                    if (i % 2 === 1) len += step; // grow spiral every 2 segments
                    dir = (dir + 1) % 4;
                }
                return pts;
            }

            const pathPts = buildSpiralPoints();

            // Segments for collision + desired directions
            const segments = [];
            for (let i = 0; i < pathPts.length - 1; i++) {
                const a = pathPts[i], b = pathPts[i + 1];
                const horiz = (a.y === b.y);
                segments.push({
                    a, b,
                    horiz,
                    minX: Math.min(a.x, b.x), maxX: Math.max(a.x, b.x),
                    minY: Math.min(a.y, b.y), maxY: Math.max(a.y, b.y)
                });
            }

            // Turn points (every interior point)
            const turns = [];
            for (let i = 1; i < pathPts.length - 1; i++) {
                turns.push({ x: pathPts[i].x, y: pathPts[i].y, index: i });
            }

            // ---------- Game state ----------
            let player, alive, distPx, pbMeters;
            let started; // startspärr

            function loadPB() {
                const v = localStorage.getItem("maze_pb_m") || "0";
                pbMeters = Math.max(0, parseFloat(v) || 0);
            }
            function savePB() {
                localStorage.setItem("maze_pb_m", pbMeters.toFixed(1));
            }

            function directionFromTo(a, b) {
                if (b.x > a.x) return { dx: 1, dy: 0 };
                if (b.x < a.x) return { dx: -1, dy: 0 };
                if (b.y > a.y) return { dx: 0, dy: 1 };
                return { dx: 0, dy: -1 };
            }

            function reset() {
                overlay.style.display = "none";
                alive = true;
                distPx = 0;

                started = false;
                startOverlay.style.display = "flex";

                const start = pathPts[0];
                const next = pathPts[1];
                const dir = directionFromTo(start, next);

                player = {
                    x: start.x,
                    y: start.y,
                    dir,
                    segIndex: 0,
                    nextTurn: 0,
                    desiredDir: null
                };

                updateHUD();
            }

            function crash() {
                if (!alive) return; // skyddar mot dubbelkrasch
                alive = false;

                const meters = distPx * metersPerPixel;
                if (meters > pbMeters) {
                    pbMeters = meters;
                    savePB();
                }

                resDist.textContent = `Distans: ${meters.toFixed(1)} m`;
                resPb.textContent = `Personbästa: ${pbMeters.toFixed(1)} m`;
                overlay.style.display = "flex";
                startOverlay.style.display = "none";
                updateHUD();
            }

            retryBtn.addEventListener("click", reset);

            function desiredDirectionAtTurn(currentSegIndex) {
                const nextSeg = segments[currentSegIndex + 1];
                if (!nextSeg) return player.dir;
                return directionFromTo(nextSeg.a, nextSeg.b);
            }

            function hasPassedTurn(turn) {
                if (player.dir.dx === 1) return player.x > turn.x;
                if (player.dir.dx === -1) return player.x < turn.x;
                if (player.dir.dy === 1) return player.y > turn.y;
                return player.y < turn.y;
            }

            function onPress() {
                if (!alive) return;

                // Startspärr: första trycket startar
                if (!started) {
                    started = true;
                    startOverlay.style.display = "none";
                    return;
                }

                const turn = turns[player.nextTurn];
                if (!turn) return;

                const distToTurn = Math.hypot(turn.x - player.x, turn.y - player.y);
                const distThreshold = speed * timingWindow;

                if (distToTurn > distThreshold) { crash(); return; } // too early
                if (hasPassedTurn(turn)) { crash(); return; }        // too late

                if (!player.desiredDir) {
                    player.desiredDir = desiredDirectionAtTurn(player.segIndex);
                }
                player.dir = player.desiredDir;
                player.desiredDir = null;

                player.segIndex += 1;
                player.nextTurn += 1;
            }

            startBtn.addEventListener("click", () => {
                if (!alive) return;
                if (!started) {
                    started = true;
                    startOverlay.style.display = "none";
                }
            });

            addEventListener("keydown", (e) => {
                if (e.code === "Space") { e.preventDefault(); onPress(); }
                if (!alive && (e.code === "Enter" || e.code === "Space")) { reset(); }
            }, { passive: false });

            canvas.addEventListener("pointerdown", (e) => {
                e.preventDefault();
                if (!alive) { reset(); return; }
                onPress();
            }, { passive: false });

            function insideCorridor(x, y) {
                const seg = segments[player.segIndex];
                if (!seg) return false;

                if (seg.horiz) {
                    const withinY = Math.abs(y - seg.a.y) <= corridorHalfWidth;
                    const withinX = (x >= seg.minX - corridorHalfWidth) && (x <= seg.maxX + corridorHalfWidth);
                    return withinX && withinY;
                } else {
                    const withinX = Math.abs(x - seg.a.x) <= corridorHalfWidth;
                    const withinY = (y >= seg.minY - corridorHalfWidth) && (y <= seg.maxY + corridorHalfWidth);
                    return withinX && withinY;
                }
            }

            // ---------- Camera ----------
            const cam = { x: 0, y: 0 };
            const zoom = 1.0;
            const lookAhead = 90;
            const camOffsetY = 60;

            function updateCamera() {
                cam.x = player.x + player.dir.dx * lookAhead;
                cam.y = player.y + player.dir.dy * lookAhead;
            }

            // ---------- Drawing ----------
            function draw() {
                // White background (world)
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(0, 0, innerWidth, innerHeight);

                updateCamera();

                // Convert world->screen
                const cx = innerWidth / 2;
                const cy = innerHeight / 2 + camOffsetY;

                function wx(x) { return (x - cam.x) * zoom + cx; }
                function wy(y) { return (y - cam.y) * zoom + cy; }

                // Optional subtle grid
                if (gridEnabled) {
                    ctx.globalAlpha = 0.06;
                    ctx.strokeStyle = "#000";
                    ctx.lineWidth = 1;

                    const grid = 80;
                    const leftW = cam.x - cx;
                    const topW = cam.y - cy;
                    const rightW = cam.x + cx;
                    const bottomW = cam.y + cy;

                    const gx0 = Math.floor(leftW / grid) * grid;
                    const gy0 = Math.floor(topW / grid) * grid;

                    for (let x = gx0; x < rightW + grid; x += grid) {
                        ctx.beginPath();
                        ctx.moveTo(wx(x), wy(topW));
                        ctx.lineTo(wx(x), wy(bottomW));
                        ctx.stroke();
                    }
                    for (let y = gy0; y < bottomW + grid; y += grid) {
                        ctx.beginPath();
                        ctx.moveTo(wx(leftW), wy(y));
                        ctx.lineTo(wx(rightW), wy(y));
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                }

                // Maze look: "double stroke" -> black walls + white corridor
                const corridorWidth = corridorHalfWidth * 2;

                ctx.lineCap = "round";
                ctx.lineJoin = "round";

                // 1) Walls
                ctx.strokeStyle = "#000";
                ctx.lineWidth = corridorWidth + wallThickness * 2;
                ctx.beginPath();
                ctx.moveTo(wx(pathPts[0].x), wy(pathPts[0].y));
                for (let i = 1; i < pathPts.length; i++) {
                    ctx.lineTo(wx(pathPts[i].x), wy(pathPts[i].y));
                }
                ctx.stroke();

                // 2) Corridor
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = corridorWidth;
                ctx.beginPath();
                ctx.moveTo(wx(pathPts[0].x), wy(pathPts[0].y));
                for (let i = 1; i < pathPts.length; i++) {
                    ctx.lineTo(wx(pathPts[i].x), wy(pathPts[i].y));
                }
                ctx.stroke();

                // Guideline (centerline)
                ctx.strokeStyle = "rgba(30,90,255,0.85)";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(wx(pathPts[0].x), wy(pathPts[0].y));
                for (let i = 1; i < pathPts.length; i++) {
                    ctx.lineTo(wx(pathPts[i].x), wy(pathPts[i].y));
                }
                ctx.stroke();

                // Player
                ctx.fillStyle = alive ? "#111" : "rgba(0,0,0,0.35)";
                ctx.beginPath();
                ctx.arc(wx(player.x), wy(player.y), 10, 0, Math.PI * 2);
                ctx.fill();

                // Next turn marker (subtle)
                const t = turns[player.nextTurn];
                if (t && alive) {
                    ctx.strokeStyle = "rgba(0,0,0,0.25)";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(wx(t.x), wy(t.y), 18, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            function updateHUD() {
                const meters = distPx * metersPerPixel;
                distEl.textContent = `Distans: ${meters.toFixed(1)} m`;
                pbEl.textContent = `PB: ${pbMeters.toFixed(1)} m`;
            }

            // ---------- Loop ----------
            let last = performance.now();
            function tick(now) {
                const dt = Math.min(0.033, (now - last) / 1000);
                last = now;

                if (alive && started) {
                    player.x += player.dir.dx * speed * dt;
                    player.y += player.dir.dy * speed * dt;
                    distPx += speed * dt;

                    if (!insideCorridor(player.x, player.y)) {
                        crash();
                    }
                }

                // Always draw (even before start)
                updateHUD();
                draw();
                requestAnimationFrame(tick);
            }

            // ---------- Init ----------
            loadPB();
            reset();
            requestAnimationFrame(tick);
        })();
    </script>
</body>
</html>
